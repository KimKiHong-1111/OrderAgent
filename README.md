# 🚀 OrderAgent 프로젝트


AWS LAMBDA 기반 자동 재고관리시스템입니다.
---

## 프로젝트 개요
### [문제 상황] 

- 오픈마켓/쇼핑몰(예: 삼성라이온즈몰)에서 재고 관리를 수동으로 하기에는 제품 수가 많고, 품절 발생 시 실시간으로 손해가 발생
- 사람이 수작업으로 처리할 경우 실수 발생 가능성이 존재하며, 이를 위한 인건비(월 300만 원 수준)도 부담
- 해당 사이트에서 공식적인 OpenAPI 가 제공되지 않아 외부 연동이 어려움
- IP 기반 자동화 서비스는 외부 API 호출 비용이 높음

### [해결 방안]

소프트웨어 개발

- **Selenium 기반 웹 크롤러 + 서버리스 아키텍처(Lambda)** 를 활용한 **자동화 재고관리 시스템** 개발
- 소프트웨어는 사람이 저지를 수 있는 실수를 줄이고, 재고 품절 가능성을 낮출 수 있으며, 비용도 절감할 수 있음

---

## 📈 기대 효과

| 항목         | 기존 방식 (수동 관리)      | OrderAgent 도입 시             |
|--------------|---------------------------|-------------------------------|
| 인건비        | 월 300만원 이상              | 0원 (Lambda 사용)              |
| 실수 발생률    | 높음                          | 낮음 (코드 기반 자동 판단)        |
| 응답 속도     | 느림 (사람이 직접 확인해야 함)   | 빠름 (5분 단위 자동 크롤링)       |

---

## 💡 서버리스 아키텍처 도입 이유: EC2 vs Lambda

### ⚖️ EC2 vs AWS Lambda 비교

| 항목                  | EC2 기반 (서버 있음)                      | Lambda 기반 (서버리스)                         |
|-----------------------|------------------------------------------|------------------------------------------------|
| 비용 구조              | 인스턴스 항상 실행 → 고정 비용 발생        | 사용한 만큼만 과금 → 초 단위 비용 효율적        |
| 확장성                | 수동 설정 필요 (Auto Scaling 등)          | 자동 확장 (요청 수에 따라 자동 대응)            |
| 운영/관리              | OS, 패치, 배포 등 인프라 직접 관리 필요     | 코드만 관리 → 운영 부담 최소화                  |
| 콜드 스타트            | 없음                                    | 존재 (Java는 다소 느릴 수 있음)                |
| 실행 시간              | 무제한                                   | 최대 15분 이내 제한                             |
| 배포 속도              | 수동/스크립트 필요                        | `sam deploy`로 신속 배포                         |
| 복잡한 작업 처리        | 장기 작업 적합                            | 단기, 주기적 작업에 적합                         |

### ✅ OrderAgent에 Lambda가 적합한 이유

- 재고 크롤링은 **짧은 시간에 끝나는 주기적 작업** 이기 때문에 15분 제한과 잘 맞음
- 대부분의 시간은 **유휴 상태** 이므로 EC2 사용은 비용 낭비
- 빠르게 배포하고 확장할 수 있는 **서버리스 특성**이 이상적
- 인프라 관리 없이 재고 수집 → 저장 → 판단 로직을 전부 Lambda에서 처리 가능

> 📌 따라서 OrderAgent는 **비용 절감, 유지보수 최소화, 확장성 확보** 측면에서  
>       **서버리스 아키텍처**로 설계 했습니다.

## 🧠 시스템 아키텍처

```aiignore
[사용자]
   │
   └─▶ [프론트엔드 (React SPA)]
            │
            ▼
     [백엔드 API Gateway (AWS Lambda)]
            │
            ├─▶ [웹 크롤링 (Selenium)]
            ├─▶ [재고 파싱 및 저장 (DynamoDB)]
            └─▶ [주문 감지 및 기록]

```

> 💡 자동 스케줄링 실행은 **Lambda + CloudWatch Events** 로 처리되며, 수동 호출은 REST API로도 가능

---

## ⚙️ 주요 기능

| 기능 항목            | 설명                                      |
|---------------------|-----------------------------------------|
| 🔎 웹 크롤링        | 상품 목록 페이지 및 상세페이지에서 옵션 재고 상태 ([품절] 여부) 크롤링 |
| 💾 재고 저장        | 상품 정보 및 옵션 상태를 DB(DynamoDB)에 저장         |
| ⏰ 자동 스케줄링     | 일정 주기마다 Lambda가 실행되어 자동 수집 및 판단         |
| 🚨 재고 부족 감지    | 옵션이 품절되거나 수량이 기준 이하일 경우 자동 주문 시도        |
| 🌐 프론트엔드 연동   | 상품 리스트/재고 상태를 확인할 수 있는 대시보드 제공          |
| 📩 수동 API 트리거  | 버튼 클릭으로 수동 크롤링 실행 가능         |


## 패키지 구조
```
OrderAgent
├── orderagent-admin/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   └── api/               # API 호출 함수
│   ├── vite.config.ts
│   └── package.json
├── build.gradle
├── template.yaml              # AWS SAM 템플릿
└── src/main/java/api/orderagent
    ├── config/                # DynamoDB 설정, CORS 설정 등
    ├── controller/            # REST API 컨트롤러
    ├── crawler/               # 크롤링 로직 (Selenium 기반)
    ├── domain/
    │   └── entity/            # DynamoDB 엔티티 (Product 등)
    ├── dto/                   # ProductRecord, ProductResDto 등 DTO 클래스
    ├── lambda/                # Lambda 핸들러 (스케줄러 호출 진입점)
    ├── runner/                # 어플리케이션 실행부 (Spring Boot Lambda용)
    ├── scheduler/             # 스케줄 트리거 설정
    ├── service/               # 크롤링 결과 저장, 재고 조회, 자동 주문 처리 등 핵심 로직
    └── utils/                 # 유틸리티 클래스
```

## 🛠 기술 스택

### 백엔드

- **Java 17 (Temurin)**
- **Spring Boot 3.5.3**
- **Spring Data JPA**
- **MySQL 8** (로컬 테스트용)
- **Amazon DynamoDB** (서버리스 운영용)
- **AWS Lambda (Java Runtime)**
- **AWS CloudWatch Scheduler**
- **AWS SAM CLI** (배포 자동화)

### 🖥 프론트엔드
- React + TypeScript
- Vite (Build Tool)
- Tailwind CSS (스타일링)
- React Query / Axios (API 연동)
- Chart.js (재고 시각화)

### 크롤링

- **Selenium 4.21.0**
- **Jsoup** (DOM 파싱 보조)
- **WebDriverManager** (크롬 드라이버 자동화)

### 기타

- **Lombok** (코드 간결화)
- **SLF4J + Logback** (로그)

---

## 🔁 실행 흐름 요약

1. Lambda 스케줄 트리거 실행 (정기)
2. 웹사이트 접속 및 상품 목록/옵션 크롤링
3. 옵션 텍스트에서 `[품절]` 여부 파악
4. DB에 저장
5. 조건 만족 시 자동 주문 로그 기록

---

## 💥 Trouble Shooting

### 🐞 문제: Selenium에서 옵션 텍스트가 빈 문자열로 수집됨

- 원인: `<option>` 태그가 JS 렌더링 후 생성되어 `.getText()`가 동작하지 않음
- 해결:
    - WebDriver의 `WebDriverWait`을 활용해 DOM 요소가 렌더링될 때까지 대기
    - `.getAttribute("innerText")`로 대체하여 텍스트 추출 성공

### 🐞 문제: DynamoDB 테이블 조회 속도 느림

- 원인: Sort Key 조건 없이 Scan만 사용 중
- 해결:
    - `productUrl + 옵션명`으로 구성된 Composite Key를 사용하여 `Query` 방식으로 변경
  
---
## 🧠 배운 점 & 느낀 점

이번 프로젝트는 제가 처음으로 **크롤링과 서버리스 아키텍처**에 도전한 경험이었습니다.

### 📌 크롤링

- Selenium을 처음 다뤄보면서, 단순히 데이터를 긁는 것이 아니라  
  **동적 페이지 구조, 렌더링 타이밍, 요소 대기** 같은 실제 웹 환경의 복잡함을 이해하게 되었습니다.
- 특히 옵션 텍스트가 비어 있는 문제를 해결하며  
  **DOM 구조와 JS 렌더링 타이밍의 관계**에 대해서 공부 할 수 있었습니다.

### ☁️ 서버리스 아키텍처

- 기존에는 항상 서버가 존재하는 구조(Spring + EC2)만 써봤는데,  
  **AWS Lambda를 활용한 서버리스 방식**은 배포/운영 비용을 획기적으로 줄일 수 있었습니다.
- Lambda의 콜드 스타트, 실행 시간 제한 등 **기술적 제약**을 직접 다뤄보며  
  **서버리스가 언제 적합하고 언제 부적합한지**를 명확히 구분할 수 있게 되었습니다.

### ✅ 그 외 성장

- 단순히 기능을 만드는 데서 멈추지 않고,  
  **자동화, 장애 처리, 성능 최적화(Query vs Scan)** 등  
  실무에서 필요한 고려사항까지 경험할 수 있었습니다.
- 무엇보다, 혼자서 처음부터 끝까지 아키텍처를 설계하고 구현하며  
  **시스템을 보는 시야**가 넓어졌고, 기술 선택에 대한 근거를 설명할 수 있게 되었습니다.
